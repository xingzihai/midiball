项目技术规格书 (Technical Design Document)
项目名称： MidiMarble (弹球音序器)
版本： 1.1（阶段2.5更新）
核心理念： 逆向程序生成 (Reverse Procedural Generation) —— 以时间换空间，通过物理弹射轨迹可视化音乐结构。
1. 系统架构概览 (System Architecture)
本项目采用 C/S (Client-Server) 分离架构 或 离线生成/在线播放架构。系统被严格划分为两个独立的黑盒模块，中间通过自定义的 .mdbl (Marble Data Blob) 文件格式进行数据交换。
1.1 模块划分
 * Encoder (后端/核心计算层)： 负责"大脑"的工作。接收标准 MIDI 文件，执行复杂的路径规划、防碰撞模拟、和弦拓扑构建，最终输出包含所有几何信息和时间戳的 .mdbl 文件。
 * Player (前端/表现层)： 负责"眼睛和耳朵"的工作。运行在 Web 浏览器中，解析 .mdbl 文件，通过 Canvas/WebGL 渲染动画，并通过 Web Audio API 合成声音。
2. 核心模块 A：编码器 (The Encoder)
目标： 将时间维度的音乐数据转换为空间维度的几何数据。
输入： .mid (Standard MIDI File)
输出： .mdbl (自定义 JSON/Binary 格式)
2.1 核心算法流程
编码器并非简单的翻译器，而是一个预演模拟器。它必须在没有任何渲染的情况下，在内存中"跑"完整个物理过程。
2.1.1 数据预处理
 * 轨道合并： 将 MIDI 多轨道合并为主时间轴，但保留乐器通道信息（用于后续定义墙的颜色）。
 * 和弦识别（阶段2.5实现）： 扫描时间轴，将时间差极小（<50ms）的多个 Note On 事件标记为"和弦组 (Chord Group)"。由chord_grouper.py 模块处理。
2.1.2 路径规划与空间映射 (核心难点)
系统需维护一个虚拟游标 (x, y) 和当前速度向量 \vec{v}。
 * 动态速度计算 (Dynamic Velocity)：
   * 计算当前时间窗口内的音符密度 (NPS)。
   * 建立映射函数：v(t) = f(\text{NPS})。密度越高，速度越慢；密度越低，速度越快。
   * 生成速度变化曲线，使用smoothstep插值+三点平均平滑。
 * 距离计算：
   * 根据 \Delta t (下一个音符的时间差) 和 v(t)，计算小球飞行距离 d。
 *墙体放置策略（阶段2.5改进）：
   * 交替横竖正交优先：偶数墙横放(法线0,±1)，奇数墙竖放(法线±1,0)。
   * 三级放置：正交优先 → 随机方向重试(30次) → 智能强制放置(28候选)。
 * 碰撞检测与回溯 (Backtracking)：
   * 空间网格哈希加速：collision_detector.py 使用50px网格单元O(1)查询邻近墙体。
   * 射线-线段相交检测 +墙体最小间距检测(25px)。
   * 回溯机制：每墙最多回溯15次×总墙数，回滚至上一节点重新尝试。
2.1.3 和弦拓扑处理 (Split & Merge)
 * 阶段2.5已完成基础标记：
   * 分光镜 (Splitter)： 和弦组第一个音符标记为 type="SPLITTER"，携带 chordNotes 数组。
   * 汇光镜 (Merger)： 和弦组后第一个满足间距≥25px的单音符标记为 type="MERGER"。* 当前行为：分光镜处小球不分裂，音频同时播放所有和弦音符。
 * 阶段三待实现完整拓扑：
   * 分裂器 (Splitter)： 生成 N 个子球（N=和弦音符数），为每个子球分配局部路径，需保证互不碰撞。
   * 汇合器 (Merger)： 强制计算所有子球的反射角，使其轨迹精确汇聚于同一个Merger点。
3. 自定义文件格式：.mdbl 规范
.mdbl 文件应包含渲染所需的全部静态数据，前端播放器不应进行任何物理计算，只负责插值播放。
数据结构 (JSON)：
{
  "meta": {
    "title": "Song Name",
    "bpm": 120,
    "totalTime": 180000,
    "mapBounds": { "minX": -5000, "maxX": 5000, "minY": -5000, "maxY": 5000 }
  },
  "assets": {
    "instruments": [ { "id": 0, "name": "Piano", "color": "#FF0000" } ]
  },
  "timeline": [
    {
      "id": 1, "time": 1000, "type": "WALL",
      "pos": { "x": 100, "y": 200 }, "rotation": 45,
      "instrumentId": 0, "note": 60, "velocity": 80
    },
    {
      "id": 2, "time": 1500, "type": "SPLITTER",
      "pos": { "x": 300, "y": 400 }, "rotation": 0,
      "instrumentId": 0, "note": 60, "velocity": 80,
      "chordNotes": [
        { "note": 64, "velocity": 75, "instrumentId": 0 },
        { "note": 67, "velocity": 70, "instrumentId": 0 }
      ]
    },
    {
      "id": 5, "time": 3000, "type": "MERGER",
      "pos": { "x": 500, "y": 300 }, "rotation": 90,
      "instrumentId": 0, "note": 72, "velocity": 80
    }
  ],
  "ballPath": [
    { "time": 0, "x": 0, "y": 0 },
    { "time": 1000, "x": 100, "y": 200 }
  ]
}

type字段值：
 * "WALL" — 普通碰撞墙（默认）
 * "SPLITTER" — 分光镜，携带chordNotes
 * "MERGER" — 汇光镜

4. 核心模块 B：播放器 (The Player)
目标： 解析 .mdbl 并提供极致的视听体验。
平台： Web (PC/Mobile)
4.1 渲染引擎 (Visual)
 * 视口管理 (Camera System)：
   * 实现智能跟随：摄像机中心锁定在当前活跃小球的重心。
   * 实现动态缩放：根据事件密度动态调整 Zoom Level (0.5~1.6)。
     * 单球模式： Zoom 放大，展示细节。
     * 和弦分裂模式（阶段三）： Zoom 缩小，确保所有分裂球都在屏幕内。
 * 特效系统：
   * 墙体状态： 未激活（灰色/半透明） -> 激活瞬间（白色闪烁150ms） -> 已激活（乐器对应色+光晕淡出600ms）。
   * SPLITTER标记：菱形边框(金色) + 菱形光晕。
   * MERGER标记：圆形边框(绿色) + 圆形光晕。* 拖尾系统：15段渐变拖尾跟随小球运动。
4.2 音频引擎 (Audio)
 * 精准调度： 使用 Tone.js Transport 高精度调度，预调度所有音符到时间轴。
 * 和弦播放（阶段2.5）： SPLITTER触发时同时播放主音符+所有chordNotes。
 * 音源：PolySynth(triangle波) + ADSR包络。
5. 开发路线图与里程碑 (Roadmap)
阶段一：原型验证 (MVP) - "单球跑通"✅
 * Encoder: 实现最简单的单旋律解析，固定速度，无防碰撞（允许重叠）。
 * Player: 能够读取坐标并在 Canvas 上画出黑墙；小球按轨迹运动；撞墙发声。
 * 交付物： 一个只能跑单音旋律的 Web Demo。
阶段二：智能算法介入 - "避障与变速" ✅
 * Encoder: 引入"回溯算法"解决路径重叠问题；引入"动态速度"计算。
 * Player: 增加摄像机跟随功能，优化连贯性。
 * 交付物： 可以生成复杂、不重叠、速度有快慢变化的地图。
阶段2.5：间距保障与和弦标记 - "分光镜基础" ✅
 * Encoder: 交替横竖正交墙体放置；和弦分组(chord_grouper.py)；SPLITTER/MERGER类型标记；三级放置策略实现零碰撞。
 * Player: 和弦音频同时播放；SPLITTER菱形/MERGER圆形视觉标记。* 交付物： 零碰撞地图+和弦数据结构完备，为阶段三子球路径打基础。
阶段三：复杂拓扑 - "和弦分裂"
 * Encoder: 开发子球独立路径规划（SPLITTER→各音符墙→MERGER汇合点）。
 * Player: 支持多球并发渲染，摄像机增加包围盒自动缩放逻辑。
 * 交付物： 能够完美演绎复杂钢琴曲的版本。
阶段四：产品化与优化
 * UI/UX: 添加上传界面、进度条、播放控制、颜色主题切换。
 * 性能优化: 针对长乐曲（成千上万个墙）进行渲染剔除（Culling），只渲染视野内的物体。
6. 技术栈推荐 (Tech Stack)
后端 (Encoder)
 * 语言： Python (因其强大的数学库) 。
 * 库：
   * mido - MIDI 解析。
   * numpy - 向量计算与矩阵运算。
前端 (Player)
 * 语言： TypeScript (保证数据结构严谨)。
 * 渲染库： Pixi.js - 2D 性能之王，适合处理大量粒子和几何图形。
 * 音频库： Tone.js - Web Audio API 的最佳封装库，处理调度极为精准。
