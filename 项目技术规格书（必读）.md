项目技术规格书 (Technical Design Document)
项目名称： MidiMarble (弹球音序器)
版本： 1.0
核心理念： 逆向程序生成 (Reverse Procedural Generation) —— 以时间换空间，通过物理弹射轨迹可视化音乐结构。
1. 系统架构概览 (System Architecture)
本项目采用 C/S (Client-Server) 分离架构 或 离线生成/在线播放架构。系统被严格划分为两个独立的黑盒模块，中间通过自定义的 .mdbl (Marble Data Blob) 文件格式进行数据交换。
1.1 模块划分
 * Encoder (后端/核心计算层)： 负责“大脑”的工作。接收标准 MIDI 文件，执行复杂的路径规划、防碰撞模拟、和弦拓扑构建，最终输出包含所有几何信息和时间戳的 .mdbl 文件。
 * Player (前端/表现层)： 负责“眼睛和耳朵”的工作。运行在 Web 浏览器中，解析 .mdbl 文件，通过 Canvas/WebGL 渲染动画，并通过 Web Audio API 合成声音。
2. 核心模块 A：编码器 (The Encoder)
目标： 将时间维度的音乐数据转换为空间维度的几何数据。
输入： .mid (Standard MIDI File)
输出： .mdbl (自定义 JSON/Binary 格式)
2.1 核心算法流程
编码器并非简单的翻译器，而是一个预演模拟器。它必须在没有任何渲染的情况下，在内存中“跑”完整个物理过程。
2.1.1 数据预处理
 * 轨道合并： 将 MIDI 多轨道合并为主时间轴，但保留乐器通道信息（用于后续定义墙的颜色）。
 * 和弦识别： 扫描时间轴，将时间差极小（如 <20ms）的多个 Note On 事件标记为“和弦组 (Chord Group)”。
2.1.2 路径规划与空间映射 (核心难点)
系统需维护一个虚拟游标 (x, y) 和当前速度向量 \vec{v}。
 * 动态速度计算 (Dynamic Velocity)：
   * 计算当前时间窗口内的音符密度 (NPS)。
   * 建立映射函数：v(t) = f(\text{NPS})。密度越高，速度越慢；密度越低，速度越快。
   * 生成速度变化曲线，确保加减速平滑（使用贝塞尔曲线插值）。
 * 距离计算：
   * 根据 \Delta t (下一个音符的时间差) 和 v(t)，计算小球飞行距离 d。
 * 碰撞检测与回溯 (Backtracking)：
   * 试错法： 在生成下一个墙壁角度时，随机尝试一个角度 \theta。
   * 射线检测： 检查从当前点沿 \theta 延伸 d 距离的路径是否与已生成的几何体（旧墙）相交。
   * 回溯机制： 若检测到碰撞或陷入死胡同，回滚至上一个节点（N-1），重新随机生成上一个墙的角度，直到找到一条无碰撞路径。
2.1.3 和弦拓扑处理 (Split & Merge)
 * 分裂器 (Splitter)： 在和弦组前生成一个“多棱镜”节点。
   * 生成 N 个子球（$N=$和弦音符数）。
   * 为每个子球分配局部路径，需保证互不碰撞。
 * 汇合器 (Merger)： 在和弦结束后的第一个单音符位置生成“透镜”节点。
   * 强制计算所有子球的反射角，使其在撞击各自的音符墙后，轨迹精确汇聚于同一个点（Merger点）。
3. 自定义文件格式：.mdbl 规范
.mdbl 文件应包含渲染所需的全部静态数据，前端播放器不应进行任何物理计算，只负责插值播放。
建议数据结构 (JSON 示例)：
{
  "meta": {
    "title": "Song Name",
    "bpm": 120,
    "totalTime": 180000,
    "mapBounds": { "minX": -5000, "maxX": 5000, "minY": -5000, "maxY": 5000 }
  },
  "assets": {
    "instruments": [ { "id": 0, "name": "Piano", "color": "#FF0000" } ]
  },
  "timeline": [
    {
      "id": 1,
      "time": 1000,
      "type": "WALL",
      "pos": { "x": 100, "y": 200 },
      "rotation": 45,
      "instrumentId": 0,
      "note": 60,
      "velocity": 80
    },
    {
      "id": 2,
      "time": 1500,
      "type": "SPLITTER",
      "pos": { "x": 300, "y": 400 },
      "children_paths": [ ... ]
    }
  ]
}

4. 核心模块 B：播放器 (The Player)
目标： 解析 .mdbl 并提供极致的视听体验。
平台： Web (PC/Mobile)
4.1 渲染引擎 (Visual)
 * 视口管理 (Camera System)：
   * 实现智能跟随：摄像机中心锁定在当前活跃小球的重心。
   * 实现动态缩放：根据活跃小球的包围盒 (Bounding Box) 动态调整 Zoom Level。
     * 单球模式： Zoom 放大，展示细节。
     * 和弦分裂模式： Zoom 缩小，确保所有分裂球都在屏幕内。
 * 特效系统：
   * 墙体状态： 未激活（黑色/半透明） -> 激活瞬间（高亮发光/白色） -> 已激活（乐器对应色/霓虹光晕）。
   * 粒子系统： 撞击瞬间产生溅射粒子；小球运动带有拖尾 (Trail)。
4.2 音频引擎 (Audio)
 * 精准调度： 不要使用 setTimeout 或 requestAnimationFrame 播放声音（会有延迟）。必须使用 Web Audio API 的 AudioContext.currentTime 进行高精度调度。
 * 音源加载： 预加载 SoundFont (如 .sf2 转 web 格式) 或使用简单的振荡器合成。
5. 开发路线图与里程碑 (Roadmap)
阶段一：原型验证 (MVP) - "单球跑通"
 * Encoder: 实现最简单的单旋律解析，固定速度，无防碰撞（允许重叠）。
 * Player: 能够读取坐标并在 Canvas 上画出黑墙；小球按轨迹运动；撞墙发声。
 * 交付物： 一个只能跑单音旋律的 Web Demo。
阶段二：智能算法介入 - "避障与变速"
 * Encoder: 引入“回溯算法”解决路径重叠问题；引入“动态速度”计算。
 * Player: 增加摄像机跟随功能，优化连贯性。
 * 交付物： 可以生成复杂、不重叠、速度有快慢变化的地图。
阶段三：复杂拓扑 - "和弦分裂"
 * Encoder: 开发“分裂”与“汇合”的几何计算逻辑。
 * Player: 支持多球并发渲染，摄像机增加自动缩放逻辑。
 * 交付物： 能够完美演绎复杂钢琴曲的版本。
阶段四：产品化与优化
 * UI/UX: 添加上传界面、进度条、播放控制、颜色主题切换。
 * 性能优化: 针对长乐曲（成千上万个墙）进行渲染剔除（Culling），只渲染视野内的物体。
6. 技术栈推荐 (Tech Stack)
后端 (Encoder)
 * 语言： Python (因其强大的数学库) 。
 * 库：
   * mido (Python) 或 @tonejs/midi (JS) - MIDI 解析。
   * numpy (Python) - 向量计算与矩阵运算。
   * networkx (Python) - 如果路径规划极其复杂，可用图论库辅助。
前端 (Player)
 * 语言： TypeScript (保证数据结构严谨)。
 * 渲染库：
   * Pixi.js: 2D 性能之王，适合处理大量粒子和几何图形。
   * (备选) Three.js: 如果未来打算做 3D 效果。
 * 音频库：
   * Tone.js: Web Audio API 的最佳封装库，处理调度极为精准。
